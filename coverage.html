
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bukukas-inmemory-search: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">bukukas-inmemory-search/cmd/bukukas-inmemory-search/di.go (100.0%)</option>
				
				<option value="file1">bukukas-inmemory-search/cmd/bukukas-inmemory-search/flags.go (0.0%)</option>
				
				<option value="file2">bukukas-inmemory-search/cmd/bukukas-inmemory-search/http.go (76.4%)</option>
				
				<option value="file3">bukukas-inmemory-search/cmd/bukukas-inmemory-search/http_get.go (100.0%)</option>
				
				<option value="file4">bukukas-inmemory-search/cmd/bukukas-inmemory-search/http_ping.go (76.9%)</option>
				
				<option value="file5">bukukas-inmemory-search/cmd/bukukas-inmemory-search/http_search.go (100.0%)</option>
				
				<option value="file6">bukukas-inmemory-search/cmd/bukukas-inmemory-search/http_set.go (96.2%)</option>
				
				<option value="file7">bukukas-inmemory-search/cmd/bukukas-inmemory-search/main.go (0.0%)</option>
				
				<option value="file8">bukukas-inmemory-search/cmd/bukukas-inmemory-search/prometheus.go (0.0%)</option>
				
				<option value="file9">bukukas-inmemory-search/inmemorycache/cache.go (100.0%)</option>
				
				<option value="file10">bukukas-inmemory-search/inmemorycache/di.go (100.0%)</option>
				
				<option value="file11">bukukas-inmemory-search/inmemorycache/trie.go (96.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bukukas-inmemory-search/inmemorycache"
        "net/http"

        "github.com/gorilla/mux"
)

type diContainer struct {
        flags *flags

        httpHandler  func() (http.Handler, error)
        httpRouter   func() (*mux.Router, error)
        httpHandlers *httpHandlers
        cache        func() inmemorycache.Cache
}

func newDIContainer(flg *flags) *diContainer <span class="cov8" title="1">{
        dic := &amp;diContainer{
                flags: flg,
        }
        dic.httpHandlers = newHTTPHandlers(dic)
        dic.httpRouter = newHTTPRouterDIProvider(dic)
        dic.httpHandler = newHTTPHandlerDIProvider(dic)
        dic.cache = inmemorycache.NewDIProvider()
        return dic
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flag"
        "os"
)

type flags struct {
        http    string
        logFile string
}

func getFlags() *flags <span class="cov0" title="0">{
        flg := &amp;flags{
                http: ":8080",
        }
        fs := flag.NewFlagSet("", flag.ExitOnError)
        fs.StringVar(&amp;flg.http, "http", flg.http, "HTTP ")
        fs.StringVar(&amp;flg.logFile, "log-file", flg.logFile, "log file")
        _ = fs.Parse(os.Args[1:]) // Ignore error, because it exits on error
        return flg
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bytes"
        "context"
        "encoding/json"
        "log"
        "net/http"
        "sync"

        "github.com/gorilla/mux"
        "github.com/pkg/errors"
)

func runHTTPServer(_ context.Context, dic *diContainer, addr string) error <span class="cov0" title="0">{
        h, err := dic.httpHandler()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "get http handler")
        }</span>
        <span class="cov0" title="0">log.Printf("Start HTTP server on %s", addr)
        srv := &amp;http.Server{
                Addr:    addr,
                Handler: h,
        }
        err = srv.ListenAndServe()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "listen and serve")
        }</span>
        <span class="cov0" title="0">log.Println("Stopped HTTP server")
        return nil</span>
}

func newHTTPHandler(dic *diContainer) (http.Handler, error) <span class="cov8" title="1">{
        r, err := dic.httpRouter()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "router")
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func newHTTPHandlerDIProvider(dic *diContainer) func() (http.Handler, error) <span class="cov8" title="1">{
        var v http.Handler
        var mu sync.Mutex
        return func() (_ http.Handler, err error) </span><span class="cov8" title="1">{
                mu.Lock()
                defer mu.Unlock()
                if v == nil </span><span class="cov8" title="1">{
                        v, err = newHTTPHandler(dic)
                }</span>
                <span class="cov8" title="1">return v, err</span>
        }
}

func newHTTPRouter(dic *diContainer) (*mux.Router, error) <span class="cov8" title="1">{
        r := mux.NewRouter()
        err := registerHTTPHandlers(r, dic.httpHandlers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "register")
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func newHTTPRouterDIProvider(dic *diContainer) func() (*mux.Router, error) <span class="cov8" title="1">{
        var r *mux.Router
        var mu sync.Mutex
        return func() (*mux.Router, error) </span><span class="cov8" title="1">{
                mu.Lock()
                defer mu.Unlock()
                var err error
                if r == nil </span><span class="cov8" title="1">{
                        r, err = newHTTPRouter(dic)
                }</span>
                <span class="cov8" title="1">return r, err</span>
        }
}

func registerHTTPHandlers(r *mux.Router, hs *httpHandlers) error <span class="cov8" title="1">{
        for _, v := range []struct {
                name      string
                configure func(*mux.Route) *mux.Route
                handler   func() (http.Handler, error)
        }{
                {
                        name:      "set",
                        configure: configureSetHTTPRoute,
                        handler:   hs.setterHandler,
                },
                {
                        name:      "get",
                        configure: configureGetHTTPRoute,
                        handler:   hs.getterHandler,
                },
                {
                        name:      "search",
                        configure: configureSearchHTTPRoute,
                        handler:   hs.searchHandler,
                },
                {
                        name:      "ping",
                        configure: configurePingHTTPRoute,
                        handler:   hs.pingHandler,
                },
        } </span><span class="cov8" title="1">{
                h, err := v.handler()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, v.name)
                }</span>
                <span class="cov8" title="1">v.configure(r.NewRoute()).Handler(h)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type httpHandlers struct {
        setterHandler func() (http.Handler, error)
        getterHandler func() (http.Handler, error)
        searchHandler func() (http.Handler, error)
        pingHandler   func() (http.Handler, error)
}

func newHTTPHandlers(dic *diContainer) *httpHandlers <span class="cov8" title="1">{
        return &amp;httpHandlers{
                setterHandler: newSetterHandlerDIProvider(dic),
                getterHandler: newGetterHandlerDIProvider(dic),
                searchHandler: newSearchHandlerDIProvider(dic),
                pingHandler:   newPingHandlerDIProvider(),
        }
}</span>

func onHTTPError(_ context.Context, w http.ResponseWriter, _ *http.Request, err error, resp *httpErrorResponse) <span class="cov8" title="1">{
        hd := w.Header()
        hd.Set("Content-Type", "application/json")
        w.WriteHeader(resp.Code)
        buf := &amp;bytes.Buffer{}
        enc := json.NewEncoder(buf)
        _ = enc.Encode(resp)
        _, _ = w.Write(buf.Bytes())
        log.Println("err: ", err)
}</span>

type httpErrorResponse struct {
        Message string `json:"message"`
        Code    int    `json:"-"`
}

func reverse(s string) string <span class="cov8" title="1">{
        r := []rune(s)
        for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                r[i], r[j] = r[j], r[i]
        }</span>
        <span class="cov8" title="1">return string(r)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"

        "github.com/gorilla/mux"
        "github.com/pkg/errors"
)

type getterHandler struct {
        get func(key string) (value interface{}, found bool)
}

func newGetterHandler(dic *diContainer) *getterHandler <span class="cov8" title="1">{
        return &amp;getterHandler{
                get: dic.cache().Get,
        }
}</span>

func newGetterHandlerDIProvider(dic *diContainer) func() (http.Handler, error) <span class="cov8" title="1">{
        var s *getterHandler
        var mu sync.Mutex
        return func() (http.Handler, error) </span><span class="cov8" title="1">{
                mu.Lock()
                defer mu.Unlock()
                if s == nil </span><span class="cov8" title="1">{
                        s = newGetterHandler(dic)
                }</span>
                <span class="cov8" title="1">return s, nil</span>
        }
}

func configureGetHTTPRoute(r *mux.Route) *mux.Route <span class="cov8" title="1">{
        return r.Methods(http.MethodGet).Path("/get/{key}")
}</span>

func (h *getterHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        h.handle(req.Context(), w, req)
}</span>

type getterHTTPHandlerResponseBody struct {
        Key   string      `json:"key"`
        Value interface{} `json:"value"`
}

func (h *getterHandler) handle(_ context.Context, w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(req)
        key := vars["key"]
        // get value from prefix trie
        value, ok := h.get(key)
        if !ok </span><span class="cov8" title="1">{
                onHTTPError(
                        req.Context(),
                        w,
                        req,
                        errors.New(fmt.Sprintf("key '%v' not found!", key)),
                        &amp;httpErrorResponse{
                                Code:    http.StatusNotFound,
                                Message: errors.New(fmt.Sprintf("key '%v' not found!", key)).Error(),
                        })
                return
        }</span>
        <span class="cov8" title="1">buf := &amp;bytes.Buffer{}
        enc := json.NewEncoder(buf)
        _ = enc.Encode(&amp;getterHTTPHandlerResponseBody{
                Key:   key,
                Value: value,
        })
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write(buf.Bytes())</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "net/http"
        "sync"

        "github.com/gorilla/mux"
)

type pingHandler struct { // TODO Have fun here
}

func newPingHandler() *pingHandler <span class="cov8" title="1">{
        return &amp;pingHandler{}
}</span>

func newPingHandlerDIProvider() func() (http.Handler, error) <span class="cov8" title="1">{
        var s *pingHandler
        var mu sync.Mutex
        return func() (http.Handler, error) </span><span class="cov8" title="1">{
                mu.Lock()
                defer mu.Unlock()
                if s == nil </span><span class="cov8" title="1">{
                        s = newPingHandler()
                }</span>
                <span class="cov8" title="1">return s, nil</span>
        }
}

func configurePingHTTPRoute(r *mux.Route) *mux.Route <span class="cov8" title="1">{
        return r.Methods(http.MethodGet).Path("/_ping")
}</span>

func (h *pingHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        h.handle(req.Context(), w, req)
}</span>

func (h *pingHandler) handle(_ context.Context, w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        // TODO ideas for health check?
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte("All well"))
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"

        "github.com/gorilla/mux"
        "github.com/pkg/errors"
)

type searchHandler struct {
        search func(keyPattern string, total int) []string
}

func newSearchHandler(dic *diContainer) *searchHandler <span class="cov8" title="1">{
        return &amp;searchHandler{
                search: dic.cache().PrefixMatch,
        }
}</span>

func newSearchHandlerDIProvider(dic *diContainer) func() (http.Handler, error) <span class="cov8" title="1">{
        var s *searchHandler
        var mu sync.Mutex
        return func() (http.Handler, error) </span><span class="cov8" title="1">{
                mu.Lock()
                defer mu.Unlock()
                if s == nil </span><span class="cov8" title="1">{
                        s = newSearchHandler(dic)
                }</span>
                <span class="cov8" title="1">return s, nil</span>
        }
}

func configureSearchHTTPRoute(r *mux.Route) *mux.Route <span class="cov8" title="1">{
        return r.Methods(http.MethodGet).Path("/search")
}</span>

func (h *searchHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        h.handle(req.Context(), w, req)
}</span>

type searchHTTPHandlerResponseBody struct {
        Keys []string `json:"keys"`
}

func (h *searchHandler) handle(_ context.Context, w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        var keys []string
        var keyPattern string
        if req.URL.Query().Get("prefix") != "" </span><span class="cov8" title="1">{ //nolint: gocritic // not useful suggestion
                keyPattern = req.URL.Query().Get("prefix")
                keys = h.handleQueryPattern(keyPattern, false)
        }</span> else<span class="cov8" title="1"> if req.URL.Query().Get("suffix") != "" </span><span class="cov8" title="1">{
                keyPattern = req.URL.Query().Get("suffix")
                keys = h.handleQueryPattern(keyPattern, true)
        }</span> else<span class="cov8" title="1"> {
                onHTTPError(
                        req.Context(),
                        w,
                        req,
                        errors.New("invalid search"),
                        &amp;httpErrorResponse{
                                Code:    http.StatusBadRequest,
                                Message: errors.New("invalid search").Error(),
                        })
        }</span>
        <span class="cov8" title="1">if len(keys) == 0 </span><span class="cov8" title="1">{
                onHTTPError(
                        req.Context(),
                        w,
                        req,
                        errors.New(fmt.Sprintf("key pattern '%v' not found!", keyPattern)),
                        &amp;httpErrorResponse{
                                Code:    http.StatusNotFound,
                                Message: errors.New(fmt.Sprintf("key pattern '%v' not found!", keyPattern)).Error(),
                        })
                return
        }</span>
        <span class="cov8" title="1">buf := &amp;bytes.Buffer{}
        enc := json.NewEncoder(buf)
        _ = enc.Encode(&amp;searchHTTPHandlerResponseBody{
                Keys: keys,
        })
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write(buf.Bytes())</span>
}

func (h *searchHandler) handleQueryPattern(keyPattern string, isReverse bool) []string <span class="cov8" title="1">{
        if !isReverse </span><span class="cov8" title="1">{
                return h.search(keyPattern, -1)
        }</span>
        // reverse the key to search for suffix
        <span class="cov8" title="1">keysR := h.search(reverse(keyPattern), -1)
        // reverse the result
        keys := make([]string, len(keysR))
        for i, v := range keysR </span><span class="cov8" title="1">{
                keys[i] = reverse(v)
        }</span>
        <span class="cov8" title="1">return keys</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "encoding/json"
        "net/http"
        "sync"

        "github.com/gorilla/mux"
        "github.com/pkg/errors"
)

type setterHandler struct {
        set func(key string, value interface{})
}

func newSetterHandler(dic *diContainer) *setterHandler <span class="cov8" title="1">{
        return &amp;setterHandler{
                set: dic.cache().Set,
        }
}</span>

func newSetterHandlerDIProvider(dic *diContainer) func() (http.Handler, error) <span class="cov8" title="1">{
        var s *setterHandler
        var mu sync.Mutex
        return func() (http.Handler, error) </span><span class="cov8" title="1">{
                mu.Lock()
                defer mu.Unlock()
                if s == nil </span><span class="cov8" title="1">{
                        s = newSetterHandler(dic)
                }</span>
                <span class="cov8" title="1">return s, nil</span>
        }
}

func configureSetHTTPRoute(r *mux.Route) *mux.Route <span class="cov8" title="1">{
        return r.Methods(http.MethodPost).Path("/set")
}</span>

func (h *setterHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        h.handle(req.Context(), w, req)
}</span>

type setterHTTPHandlerRequestBody struct {
        Key   string      `json:"key"`
        Value interface{} `json:"value"`
}

func (h *setterHandler) handle(_ context.Context, w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        body, err := h.decodeRequestBody(req)
        if err != nil </span><span class="cov8" title="1">{
                onHTTPError(
                        req.Context(),
                        w,
                        req,
                        err,
                        &amp;httpErrorResponse{
                                Code:    http.StatusBadRequest,
                                Message: err.Error(),
                        })
                return
        }</span>
        // set key in prefix trie
        <span class="cov8" title="1">h.set(body.Key, body.Value)

        // set reverse key in prefix trie for suffix search without "data"
        h.set(reverse(body.Key), nil)

        w.WriteHeader(http.StatusCreated)
        _, _ = w.Write([]byte("accepted"))</span>
}

func (h *setterHandler) decodeRequestBody(req *http.Request) (*setterHTTPHandlerRequestBody, error) <span class="cov8" title="1">{
        var v *setterHTTPHandlerRequestBody
        err := json.NewDecoder(req.Body).Decode(&amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "decode")
        }</span>
        <span class="cov8" title="1">if v.Key == "" </span><span class="cov8" title="1">{
                return nil, errors.New("can not set empty key")
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "log"

        "github.com/pkg/errors"
)

var version = "dev"

const (
        appName = "bukukas-inmemory-search"
)

func main() <span class="cov0" title="0">{
        err := run()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(errors.Wrap(err, "run"))
        }</span>
}

func run() error <span class="cov0" title="0">{
        log.Printf("running version: %#v, app: %#v", version, appName)
        flg := getFlags()
        ctx := context.Background()
        initPromethus()
        dic := newDIContainer(flg)
        err := runHTTPServer(ctx, dic, flg.http)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "HTTP server")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "log"
        "net/http"
        "strconv"

        "github.com/gorilla/mux"
        "github.com/pkg/errors"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func NewResponseWriter(w http.ResponseWriter) *responseWriter <span class="cov0" title="0">{
        return &amp;responseWriter{w, http.StatusOK}
}</span>

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

var totalRequests = prometheus.NewCounterVec(
        prometheus.CounterOpts{
                Name: "http_requests_total",
                Help: "Number of total requests.",
        },
        []string{"path"},
)

var responseStatus = prometheus.NewCounterVec(
        prometheus.CounterOpts{
                Name: "response_status",
                Help: "Status of HTTP response",
        },
        []string{"status"},
)

var httpDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
        Name: "http_response_time_seconds",
        Help: "Duration of HTTP requests.",
}, []string{"path"})

func prometheusMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                route := mux.CurrentRoute(r)
                path, _ := route.GetPathTemplate()

                timer := prometheus.NewTimer(httpDuration.WithLabelValues(path))
                rw := NewResponseWriter(w)
                next.ServeHTTP(rw, r)
                statusCode := rw.statusCode
                responseStatus.WithLabelValues(strconv.Itoa(statusCode)).Inc()
                totalRequests.WithLabelValues(path).Inc()

                timer.ObserveDuration()
        }</span>)
}

func initPromethus() <span class="cov0" title="0">{
        err := registerPrometheus()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">promRoute := mux.NewRouter()
        promRoute.Use(prometheusMiddleware)
        promRoute.Path("/prometheus").Handler(promhttp.Handler())
        fmt.Println("Serving requests on port :9000 for promethus")
        go func() </span><span class="cov0" title="0">{
                _ = http.ListenAndServe(":9000", promRoute)
        }</span>()
}

func registerPrometheus() error <span class="cov0" title="0">{
        err := prometheus.Register(totalRequests)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "total requests")
        }</span>
        <span class="cov0" title="0">err = prometheus.Register(responseStatus)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "response status")
        }</span>
        <span class="cov0" title="0">err = prometheus.Register(httpDuration)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "http duration")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package inmemorycache

import "sync"

// Cache represents a cache.
type Cache interface {
        // Set sets a value to the cache.
        Set(key string, value interface{})
        // Get looks up a key's value from the cache.
        Get(key string) (value interface{}, found bool)
        // PrefixMatch looks up all key matching the prefix / suffix pattern
        PrefixMatch(prefix string, total int) []string
}

// New returns a new Cache.
// All methods are by default concurrent safe by *mutex lock*.
func New() Cache <span class="cov8" title="1">{
        t := &amp;trie{}
        return &amp;lock{
                Cache: t,
        }
}</span>

func NewDIProvider() func() Cache <span class="cov8" title="1">{
        var c Cache
        var mu sync.Mutex
        return func() Cache </span><span class="cov8" title="1">{
                mu.Lock()
                defer mu.Unlock()
                if c == nil </span><span class="cov8" title="1">{
                        c = New()
                }</span>
                <span class="cov8" title="1">return c</span>
        }
}

type lock struct {
        mu sync.Mutex
        Cache
}

func (c *lock) Set(key string, value interface{}) <span class="cov8" title="1">{
        c.mu.Lock()
        c.Cache.Set(key, value)
        c.mu.Unlock()
}</span>

func (c *lock) Get(key string) (value interface{}, found bool) <span class="cov8" title="1">{
        c.mu.Lock()
        value, found = c.Cache.Get(key)
        c.mu.Unlock()
        return value, found
}</span>

func (c *lock) PrefixMatch(prefix string, total int) []string <span class="cov8" title="1">{
        c.mu.Lock()
        value := c.Cache.PrefixMatch(prefix, total)
        c.mu.Unlock()
        return value
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package inmemorycache

// DIContainer is the DI container for inmemory cache.
type DIContainer struct {
        Cache func() Cache
}

func newDIContainer() *DIContainer <span class="cov8" title="1">{
        dic := &amp;DIContainer{}
        dic.Cache = NewDIProvider()
        return dic
}</span>

// NewDIContainer returns a new DIContainer.
func NewDIContainer() *DIContainer <span class="cov8" title="1">{
        return newDIContainer()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package inmemorycache

// trie Implements the trie DS.
type trie struct {
        ChildrenNode [512]*trie
        isTerminal   bool
        Value        interface{}
}

// Set the key:value to trie "cache".
func (t *trie) Set(key string, value interface{}) <span class="cov8" title="1">{
        if len(key) &lt; 1 </span><span class="cov8" title="1">{
                t.isTerminal = true
                t.Value = value
                return
        }</span>
        <span class="cov8" title="1">index := key[0]
        if t.ChildrenNode[index] == nil </span><span class="cov8" title="1">{
                t.ChildrenNode[index] = &amp;trie{}
        }</span>
        <span class="cov8" title="1">t.ChildrenNode[index].Set(key[1:], value)</span>
}

// Get retrieve the value for key from trie "cache".
func (t *trie) Get(key string) (interface{}, bool) <span class="cov8" title="1">{
        curr := t
        for i := 0; i &lt; len(key); i++ </span><span class="cov8" title="1">{
                index := key[i]
                curr = curr.ChildrenNode[index]
                if curr == nil </span><span class="cov8" title="1">{
                        return nil, false
                }</span>
        }
        <span class="cov8" title="1">return curr.Value, curr.isTerminal</span>
}

// PrefixMatch returns the matching *keys* in the trie.
func (t *trie) PrefixMatch(prefix string, total int) []string <span class="cov8" title="1">{
        var result []string
        for i := 0; i &lt; len(prefix); i++ </span><span class="cov8" title="1">{
                index := prefix[i]
                if t.ChildrenNode[index] == nil </span><span class="cov8" title="1">{
                        return result
                }</span>
                <span class="cov8" title="1">t = t.ChildrenNode[index]</span>
        }
        <span class="cov8" title="1">if t.isTerminal &amp;&amp; t.isLastNode() </span><span class="cov8" title="1">{
                result = append(result, prefix)
                return result
        }</span>
        <span class="cov8" title="1">keys := []string{}
        if t.isTerminal </span><span class="cov8" title="1">{
                keys = append(keys, prefix)
                if total != -1 </span><span class="cov8" title="1">{
                        total--
                }</span>
        }
        <span class="cov8" title="1">if !t.isLastNode() </span><span class="cov8" title="1">{
                _, result = t.find(prefix, keys, total)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (t *trie) isLastNode() bool <span class="cov8" title="1">{
        for i := 0; i &lt; 512; i++ </span><span class="cov8" title="1">{
                if t.ChildrenNode[i] != nil </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (t *trie) find(prefix string, keys []string, repeat int) (int, []string) <span class="cov8" title="1">{
        if t.isLastNode() </span><span class="cov8" title="1">{
                if t.isTerminal &amp;&amp; len(keys) &lt; 1 </span><span class="cov0" title="0">{
                        keys = append(keys, prefix)
                }</span>
                <span class="cov8" title="1">return repeat, keys</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; 512; i++ </span><span class="cov8" title="1">{
                if repeat == 0 </span><span class="cov8" title="1">{
                        return repeat, keys
                }</span>
                <span class="cov8" title="1">r := t
                if t.ChildrenNode[i] != nil </span><span class="cov8" title="1">{
                        l := rune(i)
                        prefix += string(l)
                        r = r.ChildrenNode[i]
                        if r.isTerminal </span><span class="cov8" title="1">{
                                keys = append(keys, prefix)
                                if repeat != -1 </span><span class="cov0" title="0">{
                                        repeat--
                                }</span>
                        }
                        <span class="cov8" title="1">repeat, keys = r.find(prefix, keys, repeat)
                        prefix = prefix[0 : len(prefix)-1]</span>
                }
        }
        <span class="cov8" title="1">return repeat, keys</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
